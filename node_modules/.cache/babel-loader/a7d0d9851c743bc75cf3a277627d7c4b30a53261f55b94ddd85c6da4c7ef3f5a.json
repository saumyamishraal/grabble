{"ast":null,"code":"/**\n * Copyright (c) 2024 Amuse Labs Pvt Ltd\n * Grabble - Scrabble with Gravity\n * Core game engine with game logic\n */\n\nimport { STANDARD_SCRABBLE_DISTRIBUTION } from './types';\nimport { isValidWordLine, extractWordFromPositions, getReverseWord, containsNewTile } from './word-detection';\n\n/**\n * Core game engine for Grabble\n */\nexport class GrabbleEngine {\n  constructor(state) {\n    this.state = void 0;\n    this.state = state;\n  }\n\n  /**\n   * Get current game state\n   */\n  getState() {\n    return JSON.parse(JSON.stringify(this.state)); // Deep copy\n  }\n\n  /**\n   * Initialize a new tile bag from standard Scrabble distribution\n   */\n  static createTileBag() {\n    const bag = [];\n    for (const [letter, {\n      count,\n      points\n    }] of Object.entries(STANDARD_SCRABBLE_DISTRIBUTION)) {\n      for (let i = 0; i < count; i++) {\n        bag.push({\n          letter,\n          points\n        });\n      }\n    }\n    return this.shuffle(bag);\n  }\n\n  /**\n   * Shuffle array using Fisher-Yates algorithm\n   */\n  static shuffle(array) {\n    const shuffled = [...array];\n    for (let i = shuffled.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\n    }\n    return shuffled;\n  }\n\n  /**\n   * Initialize empty 7x7 board\n   */\n  static createEmptyBoard() {\n    const board = [];\n    for (let y = 0; y < 7; y++) {\n      board[y] = [];\n      for (let x = 0; x < 7; x++) {\n        board[y][x] = null;\n      }\n    }\n    return board;\n  }\n\n  /**\n   * Place tiles from column tops (row 0)\n   * Tiles are placed first, then gravity resolves\n   */\n  placeTiles(placements, playerId) {\n    // Place tiles at top of columns\n    for (const placement of placements) {\n      const {\n        column,\n        tile\n      } = placement;\n      if (column < 0 || column >= 7) {\n        throw new Error(`Invalid column: ${column}`);\n      }\n\n      // Find first empty cell in column (starting from top)\n      let placed = false;\n      for (let row = 0; row < 7; row++) {\n        if (this.state.board[row][column] === null) {\n          this.state.board[row][column] = {\n            ...tile,\n            playerId\n          };\n          placed = true;\n          break;\n        }\n      }\n      if (!placed) {\n        throw new Error(`Column ${column} is full`);\n      }\n    }\n\n    // Resolve gravity after all placements\n    this.resolveGravity();\n  }\n\n  /**\n   * Resolve gravity - tiles fall straight down until they hit bottom or another tile\n   */\n  resolveGravity() {\n    // Process each column independently\n    for (let col = 0; col < 7; col++) {\n      // Collect all tiles in this column (top to bottom)\n      const tiles = [];\n      for (let row = 0; row < 7; row++) {\n        const tile = this.state.board[row][col];\n        if (tile !== null) {\n          tiles.push(tile);\n          this.state.board[row][col] = null;\n        }\n      }\n\n      // Place tiles back from bottom up\n      let rowIndex = 6; // Start from bottom row\n      for (let i = tiles.length - 1; i >= 0; i--) {\n        this.state.board[rowIndex][col] = tiles[i];\n        rowIndex--;\n      }\n    }\n  }\n\n  /**\n   * Extract word from board given positions\n   * Returns the word string and validates it's a straight line\n   */\n  extractWord(positions) {\n    if (!isValidWordLine(positions)) {\n      return {\n        word: '',\n        isValid: false\n      };\n    }\n\n    // Verify all positions have tiles\n    for (const pos of positions) {\n      var _this$state$board$pos;\n      if (((_this$state$board$pos = this.state.board[pos.y]) === null || _this$state$board$pos === void 0 ? void 0 : _this$state$board$pos[pos.x]) === null) {\n        return {\n          word: '',\n          isValid: false\n        };\n      }\n    }\n    const word = extractWordFromPositions(this.state.board, positions);\n    return {\n      word,\n      isValid: word.length >= 3\n    };\n  }\n\n  /**\n   * Check if word is a palindrome (same forward and backward)\n   */\n  isPalindrome(word) {\n    const cleaned = word.replace(/\\s+/g, '').toUpperCase();\n    return cleaned === cleaned.split('').reverse().join('');\n  }\n\n  /**\n   * Check if word is an emordnilap (reverses to a different valid word)\n   * Uses the reverse word from board positions to handle multi-character tiles correctly\n   */\n  async isEmordnilap(word, positions, dictionary) {\n    const reverseWord = getReverseWord(this.state.board, positions);\n    if (!reverseWord) {\n      return false;\n    }\n    const reverseUpper = reverseWord.toUpperCase();\n    const wordUpper = word.toUpperCase();\n    return reverseUpper !== wordUpper && dictionary.has(reverseUpper);\n  }\n\n  /**\n   * Calculate word score with bonuses\n   */\n  async calculateWordScore(word, positions, dictionary) {\n    // Base score: sum of letter values\n    let baseScore = 0;\n    for (const pos of positions) {\n      const tile = this.state.board[pos.y][pos.x];\n      if (tile) {\n        baseScore += tile.points;\n      }\n    }\n    const bonuses = [];\n    let multiplier = 1;\n\n    // Check if diagonal word\n    if (positions.length > 0) {\n      const dx = positions[positions.length - 1].x - positions[0].x;\n      const dy = positions[positions.length - 1].y - positions[0].y;\n      if (dx !== 0 && dy !== 0) {\n        bonuses.push('diagonal');\n        multiplier *= 2;\n      }\n    }\n\n    // Check if palindrome\n    if (this.isPalindrome(word)) {\n      bonuses.push('palindrome');\n      multiplier *= 2;\n    }\n\n    // Check if emordnilap\n    if (await this.isEmordnilap(word, positions, dictionary)) {\n      bonuses.push('emordnilap');\n      multiplier *= 2;\n    }\n    return {\n      score: baseScore * multiplier,\n      bonuses\n    };\n  }\n\n  /**\n   * Validate word claim\n   * Returns validation result with error message if invalid\n   */\n  async validateWordClaim(claim, newlyPlacedTiles, dictionary) {\n    // Extract word\n    const {\n      word,\n      isValid\n    } = this.extractWord(claim.positions);\n    if (!isValid) {\n      return {\n        valid: false,\n        error: 'Word must be a straight line of 3+ letters'\n      };\n    }\n\n    // Check dictionary\n    if (!dictionary.has(word.toUpperCase())) {\n      return {\n        valid: false,\n        error: 'Word not in dictionary'\n      };\n    }\n\n    // Check if word contains at least one newly placed tile\n    if (!containsNewTile(claim.positions, newlyPlacedTiles)) {\n      return {\n        valid: false,\n        error: 'Word must contain at least one newly placed tile'\n      };\n    }\n\n    // Check if word already claimed\n    const wordAlreadyClaimed = this.state.claimedWords.some(cw => {\n      if (cw.word.toUpperCase() !== word.toUpperCase()) return false;\n      // Check if positions overlap (same word in same location)\n      return cw.positions.some(cwPos => claim.positions.some(claimPos => cwPos.x === claimPos.x && cwPos.y === claimPos.y));\n    });\n    if (wordAlreadyClaimed) {\n      return {\n        valid: false,\n        error: 'Word already claimed'\n      };\n    }\n\n    // Calculate score\n    const {\n      score,\n      bonuses\n    } = await this.calculateWordScore(word, claim.positions, dictionary);\n    return {\n      valid: true,\n      word,\n      score,\n      bonuses\n    };\n  }\n\n  /**\n   * Process word claims for a turn\n   * Returns validation results for each claim\n   */\n  async processWordClaims(claims, newlyPlacedTiles, dictionary) {\n    const results = [];\n    let totalScore = 0;\n    for (const claim of claims) {\n      const result = await this.validateWordClaim(claim, newlyPlacedTiles, dictionary);\n      results.push(result);\n      if (result.valid && result.score !== undefined) {\n        totalScore += result.score;\n      }\n    }\n\n    // If any claim is invalid, entire move is rejected\n    const allValid = results.every(r => r.valid);\n    if (!allValid) {\n      return {\n        valid: false,\n        results,\n        totalScore: 0\n      };\n    }\n\n    // All valid - record claimed words and update scores\n    for (let i = 0; i < claims.length; i++) {\n      const claim = claims[i];\n      const result = results[i];\n      if (result.valid && result.word && result.score !== undefined) {\n        this.state.claimedWords.push({\n          word: result.word,\n          positions: claim.positions,\n          playerId: claim.playerId,\n          score: result.score,\n          bonuses: result.bonuses || []\n        });\n\n        // Update player score\n        const player = this.state.players.find(p => p.id === claim.playerId);\n        if (player) {\n          player.score += result.score;\n        }\n      }\n    }\n    return {\n      valid: true,\n      results,\n      totalScore\n    };\n  }\n\n  /**\n   * Draw tiles from bag to fill player rack (up to 7 tiles)\n   */\n  refillPlayerRack(playerId) {\n    const player = this.state.players.find(p => p.id === playerId);\n    if (!player) {\n      throw new Error(`Player ${playerId} not found`);\n    }\n    while (player.rack.length < 7 && this.state.tileBag.length > 0) {\n      const tile = this.state.tileBag.pop();\n      player.rack.push(tile);\n    }\n  }\n\n  /**\n   * Swap tiles (player discards selected tiles, draws new ones)\n   */\n  swapTiles(playerId, tileIndices) {\n    const player = this.state.players.find(p => p.id === playerId);\n    if (!player) {\n      throw new Error(`Player ${playerId} not found`);\n    }\n\n    // Remove selected tiles from rack\n    const removedTiles = [];\n    for (const index of tileIndices.sort((a, b) => b - a)) {\n      // Sort descending to remove from end\n      if (index >= 0 && index < player.rack.length) {\n        removedTiles.push(player.rack.splice(index, 1)[0]);\n      }\n    }\n\n    // Return tiles to bag and shuffle\n    this.state.tileBag.push(...removedTiles);\n    this.state.tileBag = GrabbleEngine.shuffle(this.state.tileBag);\n\n    // Draw new tiles\n    while (player.rack.length < 7 && this.state.tileBag.length > 0) {\n      const tile = this.state.tileBag.pop();\n      player.rack.push(tile);\n    }\n  }\n\n  /**\n   * Advance to next player's turn\n   */\n  advanceTurn() {\n    const currentPlayer = this.state.players.find(p => p.id === this.state.currentPlayerId);\n    if (!currentPlayer) {\n      throw new Error(`Current player ${this.state.currentPlayerId} not found`);\n    }\n    const currentTurnOrder = currentPlayer.turnOrder;\n    const nextTurnOrder = (currentTurnOrder + 1) % this.state.players.length;\n    const nextPlayer = this.state.players.find(p => p.turnOrder === nextTurnOrder);\n    if (nextPlayer) {\n      this.state.currentPlayerId = nextPlayer.id;\n    }\n  }\n\n  /**\n   * Check win condition\n   * Returns winner ID if game is won, null otherwise\n   */\n  checkWinCondition() {\n    for (const player of this.state.players) {\n      if (player.score >= this.state.targetScore) {\n        this.state.gameStatus = 'finished';\n        this.state.winnerId = player.id;\n        return player.id;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Check if game can continue (tiles available and legal moves possible)\n   */\n  canContinueGame() {\n    // If tile bag is empty and all players have empty racks, game ends\n    if (this.state.tileBag.length === 0) {\n      const allRacksEmpty = this.state.players.every(p => p.rack.length === 0);\n      if (allRacksEmpty) {\n        return false;\n      }\n    }\n    return true;\n  }\n}","map":{"version":3,"names":["STANDARD_SCRABBLE_DISTRIBUTION","isValidWordLine","extractWordFromPositions","getReverseWord","containsNewTile","GrabbleEngine","constructor","state","getState","JSON","parse","stringify","createTileBag","bag","letter","count","points","Object","entries","i","push","shuffle","array","shuffled","length","j","Math","floor","random","createEmptyBoard","board","y","x","placeTiles","placements","playerId","placement","column","tile","Error","placed","row","resolveGravity","col","tiles","rowIndex","extractWord","positions","word","isValid","pos","_this$state$board$pos","isPalindrome","cleaned","replace","toUpperCase","split","reverse","join","isEmordnilap","dictionary","reverseWord","reverseUpper","wordUpper","has","calculateWordScore","baseScore","bonuses","multiplier","dx","dy","score","validateWordClaim","claim","newlyPlacedTiles","valid","error","wordAlreadyClaimed","claimedWords","some","cw","cwPos","claimPos","processWordClaims","claims","results","totalScore","result","undefined","allValid","every","r","player","players","find","p","id","refillPlayerRack","rack","tileBag","pop","swapTiles","tileIndices","removedTiles","index","sort","a","b","splice","advanceTurn","currentPlayer","currentPlayerId","currentTurnOrder","turnOrder","nextTurnOrder","nextPlayer","checkWinCondition","targetScore","gameStatus","winnerId","canContinueGame","allRacksEmpty"],"sources":["/Users/sanyasharma/Documents/grabble/react-ui/src/game-engine/game-engine.ts"],"sourcesContent":["/**\n * Copyright (c) 2024 Amuse Labs Pvt Ltd\n * Grabble - Scrabble with Gravity\n * Core game engine with game logic\n */\n\nimport type { Tile, Position, TilePlacement, WordClaim, ClaimedWord, GameState, Player } from './types';\nimport { STANDARD_SCRABBLE_DISTRIBUTION } from './types';\nimport { isValidWordLine, extractWordFromPositions, getReverseWord, containsNewTile } from './word-detection';\n\n/**\n * Core game engine for Grabble\n */\nexport class GrabbleEngine {\n    private state: GameState;\n\n    constructor(state: GameState) {\n        this.state = state;\n    }\n\n    /**\n     * Get current game state\n     */\n    getState(): GameState {\n        return JSON.parse(JSON.stringify(this.state)); // Deep copy\n    }\n\n    /**\n     * Initialize a new tile bag from standard Scrabble distribution\n     */\n    static createTileBag(): Tile[] {\n        const bag: Tile[] = [];\n        for (const [letter, { count, points }] of Object.entries(STANDARD_SCRABBLE_DISTRIBUTION)) {\n            for (let i = 0; i < count; i++) {\n                bag.push({ letter, points });\n            }\n        }\n        return this.shuffle(bag);\n    }\n\n    /**\n     * Shuffle array using Fisher-Yates algorithm\n     */\n    static shuffle<T>(array: T[]): T[] {\n        const shuffled = [...array];\n        for (let i = shuffled.length - 1; i > 0; i--) {\n            const j = Math.floor(Math.random() * (i + 1));\n            [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\n        }\n        return shuffled;\n    }\n\n    /**\n     * Initialize empty 7x7 board\n     */\n    static createEmptyBoard(): (Tile | null)[][] {\n        const board: (Tile | null)[][] = [];\n        for (let y = 0; y < 7; y++) {\n            board[y] = [];\n            for (let x = 0; x < 7; x++) {\n                board[y][x] = null;\n            }\n        }\n        return board;\n    }\n\n    /**\n     * Place tiles from column tops (row 0)\n     * Tiles are placed first, then gravity resolves\n     */\n    placeTiles(placements: TilePlacement[], playerId: number): void {\n        // Place tiles at top of columns\n        for (const placement of placements) {\n            const { column, tile } = placement;\n            if (column < 0 || column >= 7) {\n                throw new Error(`Invalid column: ${column}`);\n            }\n            \n            // Find first empty cell in column (starting from top)\n            let placed = false;\n            for (let row = 0; row < 7; row++) {\n                if (this.state.board[row][column] === null) {\n                    this.state.board[row][column] = {\n                        ...tile,\n                        playerId\n                    };\n                    placed = true;\n                    break;\n                }\n            }\n            \n            if (!placed) {\n                throw new Error(`Column ${column} is full`);\n            }\n        }\n\n        // Resolve gravity after all placements\n        this.resolveGravity();\n    }\n\n    /**\n     * Resolve gravity - tiles fall straight down until they hit bottom or another tile\n     */\n    private resolveGravity(): void {\n        // Process each column independently\n        for (let col = 0; col < 7; col++) {\n            // Collect all tiles in this column (top to bottom)\n            const tiles: Tile[] = [];\n            for (let row = 0; row < 7; row++) {\n                const tile = this.state.board[row][col];\n                if (tile !== null) {\n                    tiles.push(tile);\n                    this.state.board[row][col] = null;\n                }\n            }\n\n            // Place tiles back from bottom up\n            let rowIndex = 6; // Start from bottom row\n            for (let i = tiles.length - 1; i >= 0; i--) {\n                this.state.board[rowIndex][col] = tiles[i];\n                rowIndex--;\n            }\n        }\n    }\n\n    /**\n     * Extract word from board given positions\n     * Returns the word string and validates it's a straight line\n     */\n    extractWord(positions: Position[]): { word: string; isValid: boolean } {\n        if (!isValidWordLine(positions)) {\n            return { word: '', isValid: false };\n        }\n\n        // Verify all positions have tiles\n        for (const pos of positions) {\n            if (this.state.board[pos.y]?.[pos.x] === null) {\n                return { word: '', isValid: false };\n            }\n        }\n\n        const word = extractWordFromPositions(this.state.board, positions);\n        return { word, isValid: word.length >= 3 };\n    }\n\n    /**\n     * Check if word is a palindrome (same forward and backward)\n     */\n    isPalindrome(word: string): boolean {\n        const cleaned = word.replace(/\\s+/g, '').toUpperCase();\n        return cleaned === cleaned.split('').reverse().join('');\n    }\n\n    /**\n     * Check if word is an emordnilap (reverses to a different valid word)\n     * Uses the reverse word from board positions to handle multi-character tiles correctly\n     */\n    async isEmordnilap(word: string, positions: Position[], dictionary: Set<string>): Promise<boolean> {\n        const reverseWord = getReverseWord(this.state.board, positions);\n        if (!reverseWord) {\n            return false;\n        }\n        const reverseUpper = reverseWord.toUpperCase();\n        const wordUpper = word.toUpperCase();\n        return reverseUpper !== wordUpper && dictionary.has(reverseUpper);\n    }\n\n    /**\n     * Calculate word score with bonuses\n     */\n    async calculateWordScore(\n        word: string,\n        positions: Position[],\n        dictionary: Set<string>\n    ): Promise<{ score: number; bonuses: string[] }> {\n        // Base score: sum of letter values\n        let baseScore = 0;\n        for (const pos of positions) {\n            const tile = this.state.board[pos.y][pos.x];\n            if (tile) {\n                baseScore += tile.points;\n            }\n        }\n\n        const bonuses: string[] = [];\n        let multiplier = 1;\n\n        // Check if diagonal word\n        if (positions.length > 0) {\n            const dx = positions[positions.length - 1].x - positions[0].x;\n            const dy = positions[positions.length - 1].y - positions[0].y;\n            if (dx !== 0 && dy !== 0) {\n                bonuses.push('diagonal');\n                multiplier *= 2;\n            }\n        }\n\n        // Check if palindrome\n        if (this.isPalindrome(word)) {\n            bonuses.push('palindrome');\n            multiplier *= 2;\n        }\n\n        // Check if emordnilap\n        if (await this.isEmordnilap(word, positions, dictionary)) {\n            bonuses.push('emordnilap');\n            multiplier *= 2;\n        }\n\n        return {\n            score: baseScore * multiplier,\n            bonuses\n        };\n    }\n\n    /**\n     * Validate word claim\n     * Returns validation result with error message if invalid\n     */\n    async validateWordClaim(\n        claim: WordClaim,\n        newlyPlacedTiles: Position[],\n        dictionary: Set<string>\n    ): Promise<{ valid: boolean; error?: string; word?: string; score?: number; bonuses?: string[] }> {\n        // Extract word\n        const { word, isValid } = this.extractWord(claim.positions);\n        if (!isValid) {\n            return { valid: false, error: 'Word must be a straight line of 3+ letters' };\n        }\n\n        // Check dictionary\n        if (!dictionary.has(word.toUpperCase())) {\n            return { valid: false, error: 'Word not in dictionary' };\n        }\n\n        // Check if word contains at least one newly placed tile\n        if (!containsNewTile(claim.positions, newlyPlacedTiles)) {\n            return { valid: false, error: 'Word must contain at least one newly placed tile' };\n        }\n\n        // Check if word already claimed\n        const wordAlreadyClaimed = this.state.claimedWords.some(cw => {\n            if (cw.word.toUpperCase() !== word.toUpperCase()) return false;\n            // Check if positions overlap (same word in same location)\n            return cw.positions.some(cwPos =>\n                claim.positions.some(claimPos => cwPos.x === claimPos.x && cwPos.y === claimPos.y)\n            );\n        });\n        if (wordAlreadyClaimed) {\n            return { valid: false, error: 'Word already claimed' };\n        }\n\n        // Calculate score\n        const { score, bonuses } = await this.calculateWordScore(word, claim.positions, dictionary);\n\n        return {\n            valid: true,\n            word,\n            score,\n            bonuses\n        };\n    }\n\n    /**\n     * Process word claims for a turn\n     * Returns validation results for each claim\n     */\n    async processWordClaims(\n        claims: WordClaim[],\n        newlyPlacedTiles: Position[],\n        dictionary: Set<string>\n    ): Promise<{\n        valid: boolean;\n        results: Array<{ valid: boolean; error?: string; word?: string; score?: number; bonuses?: string[] }>;\n        totalScore: number;\n    }> {\n        const results = [];\n        let totalScore = 0;\n\n        for (const claim of claims) {\n            const result = await this.validateWordClaim(claim, newlyPlacedTiles, dictionary);\n            results.push(result);\n            if (result.valid && result.score !== undefined) {\n                totalScore += result.score;\n            }\n        }\n\n        // If any claim is invalid, entire move is rejected\n        const allValid = results.every(r => r.valid);\n        if (!allValid) {\n            return { valid: false, results, totalScore: 0 };\n        }\n\n        // All valid - record claimed words and update scores\n        for (let i = 0; i < claims.length; i++) {\n            const claim = claims[i];\n            const result = results[i];\n            if (result.valid && result.word && result.score !== undefined) {\n                this.state.claimedWords.push({\n                    word: result.word,\n                    positions: claim.positions,\n                    playerId: claim.playerId,\n                    score: result.score,\n                    bonuses: result.bonuses || []\n                });\n\n                // Update player score\n                const player = this.state.players.find(p => p.id === claim.playerId);\n                if (player) {\n                    player.score += result.score;\n                }\n            }\n        }\n\n        return { valid: true, results, totalScore };\n    }\n\n    /**\n     * Draw tiles from bag to fill player rack (up to 7 tiles)\n     */\n    refillPlayerRack(playerId: number): void {\n        const player = this.state.players.find(p => p.id === playerId);\n        if (!player) {\n            throw new Error(`Player ${playerId} not found`);\n        }\n\n        while (player.rack.length < 7 && this.state.tileBag.length > 0) {\n            const tile = this.state.tileBag.pop()!;\n            player.rack.push(tile);\n        }\n    }\n\n    /**\n     * Swap tiles (player discards selected tiles, draws new ones)\n     */\n    swapTiles(playerId: number, tileIndices: number[]): void {\n        const player = this.state.players.find(p => p.id === playerId);\n        if (!player) {\n            throw new Error(`Player ${playerId} not found`);\n        }\n\n        // Remove selected tiles from rack\n        const removedTiles: Tile[] = [];\n        for (const index of tileIndices.sort((a, b) => b - a)) { // Sort descending to remove from end\n            if (index >= 0 && index < player.rack.length) {\n                removedTiles.push(player.rack.splice(index, 1)[0]);\n            }\n        }\n\n        // Return tiles to bag and shuffle\n        this.state.tileBag.push(...removedTiles);\n        this.state.tileBag = GrabbleEngine.shuffle(this.state.tileBag);\n\n        // Draw new tiles\n        while (player.rack.length < 7 && this.state.tileBag.length > 0) {\n            const tile = this.state.tileBag.pop()!;\n            player.rack.push(tile);\n        }\n    }\n\n    /**\n     * Advance to next player's turn\n     */\n    advanceTurn(): void {\n        const currentPlayer = this.state.players.find(p => p.id === this.state.currentPlayerId);\n        if (!currentPlayer) {\n            throw new Error(`Current player ${this.state.currentPlayerId} not found`);\n        }\n\n        const currentTurnOrder = currentPlayer.turnOrder;\n        const nextTurnOrder = (currentTurnOrder + 1) % this.state.players.length;\n        const nextPlayer = this.state.players.find(p => p.turnOrder === nextTurnOrder);\n        \n        if (nextPlayer) {\n            this.state.currentPlayerId = nextPlayer.id;\n        }\n    }\n\n    /**\n     * Check win condition\n     * Returns winner ID if game is won, null otherwise\n     */\n    checkWinCondition(): number | null {\n        for (const player of this.state.players) {\n            if (player.score >= this.state.targetScore) {\n                this.state.gameStatus = 'finished';\n                this.state.winnerId = player.id;\n                return player.id;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Check if game can continue (tiles available and legal moves possible)\n     */\n    canContinueGame(): boolean {\n        // If tile bag is empty and all players have empty racks, game ends\n        if (this.state.tileBag.length === 0) {\n            const allRacksEmpty = this.state.players.every(p => p.rack.length === 0);\n            if (allRacksEmpty) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}