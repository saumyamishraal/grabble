{"ast":null,"code":"/**\n * Copyright (c) 2024 Amuse Labs Pvt Ltd\n * Grabble - Scrabble with Gravity\n * Game state manager for turn order, player management, and game lifecycle\n */\n\nimport { GrabbleEngine } from './game-engine';\n\n/**\n * Game state manager - handles game initialization, player management, and lifecycle\n */\nexport class GameStateManager {\n  /**\n   * Create a new game with specified number of players\n   */\n  static createNewGame(numPlayers, playerNames, targetScore = 100) {\n    if (numPlayers < 2 || numPlayers > 4) {\n      throw new Error('Game must have 2-4 players');\n    }\n    if (playerNames.length !== numPlayers) {\n      throw new Error('Player names array must match number of players');\n    }\n\n    // Create tile bag\n    const tileBag = GrabbleEngine.createTileBag();\n\n    // Create players with random turn order\n    const turnOrders = [0, 1, 2, 3].slice(0, numPlayers);\n    // Shuffle turn orders\n    for (let i = turnOrders.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [turnOrders[i], turnOrders[j]] = [turnOrders[j], turnOrders[i]];\n    }\n    const playerColors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A']; // Distinct colors for 4 players\n    const players = playerNames.map((name, index) => ({\n      id: index,\n      name,\n      color: playerColors[index],\n      score: 0,\n      rack: [],\n      turnOrder: turnOrders[index]\n    }));\n\n    // Deal initial tiles to each player\n    for (const player of players) {\n      for (let i = 0; i < 7; i++) {\n        if (tileBag.length > 0) {\n          player.rack.push(tileBag.pop());\n        }\n      }\n    }\n\n    // Find starting player (lowest turnOrder)\n    const startingPlayer = players.reduce((min, p) => p.turnOrder < min.turnOrder ? p : min);\n    const state = {\n      board: GrabbleEngine.createEmptyBoard(),\n      players,\n      currentPlayerId: startingPlayer.id,\n      tileBag,\n      claimedWords: [],\n      targetScore,\n      gameStatus: 'playing'\n    };\n    return new GameStateManager(state);\n  }\n\n  /**\n   * Load game from saved state\n   */\n  static loadGame(state) {\n    return new GameStateManager(state);\n  }\n  constructor(state) {\n    this.engine = void 0;\n    this.state = void 0;\n    this.state = state;\n    this.engine = new GrabbleEngine(state);\n  }\n\n  /**\n   * Get current game state\n   */\n  getState() {\n    return this.engine.getState();\n  }\n\n  /**\n   * Get game engine (for game logic operations)\n   */\n  getEngine() {\n    return this.engine;\n  }\n\n  /**\n   * Get current player\n   */\n  getCurrentPlayer() {\n    const player = this.state.players.find(p => p.id === this.state.currentPlayerId);\n    if (!player) {\n      throw new Error(`Current player ${this.state.currentPlayerId} not found`);\n    }\n    return player;\n  }\n\n  /**\n   * Get player by ID\n   */\n  getPlayer(playerId) {\n    return this.state.players.find(p => p.id === playerId);\n  }\n\n  /**\n   * Get all players sorted by turn order\n   */\n  getPlayersByTurnOrder() {\n    return [...this.state.players].sort((a, b) => a.turnOrder - b.turnOrder);\n  }\n\n  /**\n   * Check if it's a specific player's turn\n   */\n  isPlayerTurn(playerId) {\n    return this.state.currentPlayerId === playerId;\n  }\n\n  /**\n   * Get game status\n   */\n  getGameStatus() {\n    return this.state.gameStatus;\n  }\n\n  /**\n   * Check if game is finished\n   */\n  isGameFinished() {\n    return this.state.gameStatus === 'finished';\n  }\n\n  /**\n   * Get winner if game is finished\n   */\n  getWinner() {\n    if (!this.isGameFinished() || this.state.winnerId === undefined) {\n      return null;\n    }\n    return this.getPlayer(this.state.winnerId) || null;\n  }\n\n  /**\n   * End game and determine winner (highest score)\n   * Called when no legal moves remain\n   */\n  endGame() {\n    // Find player with highest score\n    const winner = this.state.players.reduce((max, p) => p.score > max.score ? p : max);\n    this.state.gameStatus = 'finished';\n    this.state.winnerId = winner.id;\n    return winner;\n  }\n\n  /**\n   * Serialize game state for storage\n   */\n  serialize() {\n    return JSON.stringify(this.state);\n  }\n\n  /**\n   * Deserialize game state from storage\n   */\n  static deserialize(serialized) {\n    const state = JSON.parse(serialized);\n    return new GameStateManager(state);\n  }\n\n  /**\n   * Get claimed words for a specific player\n   */\n  getClaimedWordsForPlayer(playerId) {\n    return this.state.claimedWords.filter(cw => cw.playerId === playerId);\n  }\n\n  /**\n   * Get all claimed words\n   */\n  getAllClaimedWords() {\n    return [...this.state.claimedWords];\n  }\n\n  /**\n   * Get player scores as array\n   */\n  getPlayerScores() {\n    return this.state.players.map(p => ({\n      playerId: p.id,\n      name: p.name,\n      score: p.score\n    }));\n  }\n\n  /**\n   * Get leaderboard (players sorted by score, descending)\n   */\n  getLeaderboard() {\n    return [...this.state.players].sort((a, b) => b.score - a.score);\n  }\n}","map":{"version":3,"names":["GrabbleEngine","GameStateManager","createNewGame","numPlayers","playerNames","targetScore","Error","length","tileBag","createTileBag","turnOrders","slice","i","j","Math","floor","random","playerColors","players","map","name","index","id","color","score","rack","turnOrder","player","push","pop","startingPlayer","reduce","min","p","state","board","createEmptyBoard","currentPlayerId","claimedWords","gameStatus","loadGame","constructor","engine","getState","getEngine","getCurrentPlayer","find","getPlayer","playerId","getPlayersByTurnOrder","sort","a","b","isPlayerTurn","getGameStatus","isGameFinished","getWinner","winnerId","undefined","endGame","winner","max","serialize","JSON","stringify","deserialize","serialized","parse","getClaimedWordsForPlayer","filter","cw","getAllClaimedWords","getPlayerScores","getLeaderboard"],"sources":["/Users/sanyasharma/Documents/grabble/react-ui/src/game-engine/game-state-manager.ts"],"sourcesContent":["/**\n * Copyright (c) 2024 Amuse Labs Pvt Ltd\n * Grabble - Scrabble with Gravity\n * Game state manager for turn order, player management, and game lifecycle\n */\n\nimport type { GameState, Player, Tile } from './types';\nimport { GrabbleEngine } from './game-engine';\n\n/**\n * Game state manager - handles game initialization, player management, and lifecycle\n */\nexport class GameStateManager {\n    private engine: GrabbleEngine;\n    private state: GameState;\n\n    /**\n     * Create a new game with specified number of players\n     */\n    static createNewGame(\n        numPlayers: number,\n        playerNames: string[],\n        targetScore: number = 100\n    ): GameStateManager {\n        if (numPlayers < 2 || numPlayers > 4) {\n            throw new Error('Game must have 2-4 players');\n        }\n        if (playerNames.length !== numPlayers) {\n            throw new Error('Player names array must match number of players');\n        }\n\n        // Create tile bag\n        const tileBag = GrabbleEngine.createTileBag();\n\n        // Create players with random turn order\n        const turnOrders = [0, 1, 2, 3].slice(0, numPlayers);\n        // Shuffle turn orders\n        for (let i = turnOrders.length - 1; i > 0; i--) {\n            const j = Math.floor(Math.random() * (i + 1));\n            [turnOrders[i], turnOrders[j]] = [turnOrders[j], turnOrders[i]];\n        }\n\n        const playerColors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A']; // Distinct colors for 4 players\n        const players: Player[] = playerNames.map((name, index) => ({\n            id: index,\n            name,\n            color: playerColors[index],\n            score: 0,\n            rack: [],\n            turnOrder: turnOrders[index]\n        }));\n\n        // Deal initial tiles to each player\n        for (const player of players) {\n            for (let i = 0; i < 7; i++) {\n                if (tileBag.length > 0) {\n                    player.rack.push(tileBag.pop()!);\n                }\n            }\n        }\n\n        // Find starting player (lowest turnOrder)\n        const startingPlayer = players.reduce((min, p) => \n            p.turnOrder < min.turnOrder ? p : min\n        );\n\n        const state: GameState = {\n            board: GrabbleEngine.createEmptyBoard(),\n            players,\n            currentPlayerId: startingPlayer.id,\n            tileBag,\n            claimedWords: [],\n            targetScore,\n            gameStatus: 'playing'\n        };\n\n        return new GameStateManager(state);\n    }\n\n    /**\n     * Load game from saved state\n     */\n    static loadGame(state: GameState): GameStateManager {\n        return new GameStateManager(state);\n    }\n\n    private constructor(state: GameState) {\n        this.state = state;\n        this.engine = new GrabbleEngine(state);\n    }\n\n    /**\n     * Get current game state\n     */\n    getState(): GameState {\n        return this.engine.getState();\n    }\n\n    /**\n     * Get game engine (for game logic operations)\n     */\n    getEngine(): GrabbleEngine {\n        return this.engine;\n    }\n\n    /**\n     * Get current player\n     */\n    getCurrentPlayer(): Player {\n        const player = this.state.players.find(p => p.id === this.state.currentPlayerId);\n        if (!player) {\n            throw new Error(`Current player ${this.state.currentPlayerId} not found`);\n        }\n        return player;\n    }\n\n    /**\n     * Get player by ID\n     */\n    getPlayer(playerId: number): Player | undefined {\n        return this.state.players.find(p => p.id === playerId);\n    }\n\n    /**\n     * Get all players sorted by turn order\n     */\n    getPlayersByTurnOrder(): Player[] {\n        return [...this.state.players].sort((a, b) => a.turnOrder - b.turnOrder);\n    }\n\n    /**\n     * Check if it's a specific player's turn\n     */\n    isPlayerTurn(playerId: number): boolean {\n        return this.state.currentPlayerId === playerId;\n    }\n\n    /**\n     * Get game status\n     */\n    getGameStatus(): 'waiting' | 'playing' | 'finished' {\n        return this.state.gameStatus;\n    }\n\n    /**\n     * Check if game is finished\n     */\n    isGameFinished(): boolean {\n        return this.state.gameStatus === 'finished';\n    }\n\n    /**\n     * Get winner if game is finished\n     */\n    getWinner(): Player | null {\n        if (!this.isGameFinished() || this.state.winnerId === undefined) {\n            return null;\n        }\n        return this.getPlayer(this.state.winnerId) || null;\n    }\n\n    /**\n     * End game and determine winner (highest score)\n     * Called when no legal moves remain\n     */\n    endGame(): Player {\n        // Find player with highest score\n        const winner = this.state.players.reduce((max, p) => \n            p.score > max.score ? p : max\n        );\n\n        this.state.gameStatus = 'finished';\n        this.state.winnerId = winner.id;\n\n        return winner;\n    }\n\n    /**\n     * Serialize game state for storage\n     */\n    serialize(): string {\n        return JSON.stringify(this.state);\n    }\n\n    /**\n     * Deserialize game state from storage\n     */\n    static deserialize(serialized: string): GameStateManager {\n        const state: GameState = JSON.parse(serialized);\n        return new GameStateManager(state);\n    }\n\n    /**\n     * Get claimed words for a specific player\n     */\n    getClaimedWordsForPlayer(playerId: number) {\n        return this.state.claimedWords.filter(cw => cw.playerId === playerId);\n    }\n\n    /**\n     * Get all claimed words\n     */\n    getAllClaimedWords() {\n        return [...this.state.claimedWords];\n    }\n\n    /**\n     * Get player scores as array\n     */\n    getPlayerScores(): Array<{ playerId: number; name: string; score: number }> {\n        return this.state.players.map(p => ({\n            playerId: p.id,\n            name: p.name,\n            score: p.score\n        }));\n    }\n\n    /**\n     * Get leaderboard (players sorted by score, descending)\n     */\n    getLeaderboard(): Player[] {\n        return [...this.state.players].sort((a, b) => b.score - a.score);\n    }\n}\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}