{"ast":null,"code":"/**\n * Copyright (c) 2024 Amuse Labs Pvt Ltd\n * Grabble - Scrabble with Gravity\n * Word detection utilities for finding words on the board\n */\n\n/**\n * Direction vectors for word detection\n */\nconst DIRECTIONS = [{\n  dx: 1,\n  dy: 0\n},\n// Horizontal right\n{\n  dx: 0,\n  dy: 1\n},\n// Vertical down\n{\n  dx: 1,\n  dy: 1\n},\n// Diagonal down-right\n{\n  dx: 1,\n  dy: -1\n} // Diagonal up-right\n];\n\n/**\n * Find all possible words starting from a position in a given direction\n * Returns array of word positions (each word is an array of positions)\n */\nexport function findWordsInDirection(board, startX, startY, dx, dy) {\n  var _board$;\n  const words = [];\n  const rows = board.length;\n  const cols = ((_board$ = board[0]) === null || _board$ === void 0 ? void 0 : _board$.length) || 0;\n\n  // Start from the given position and extend in the direction\n  let currentWord = [];\n\n  // Move backwards first to find the start of any word containing this position\n  let x = startX;\n  let y = startY;\n\n  // Go backwards until we hit an empty cell or board edge\n  while (x >= 0 && x < cols && y >= 0 && y < rows && board[y][x] !== null) {\n    x -= dx;\n    y -= dy;\n  }\n\n  // Move forward one step (we went one too far back)\n  x += dx;\n  y += dy;\n\n  // Now collect positions going forward\n  while (x >= 0 && x < cols && y >= 0 && y < rows) {\n    if (board[y][x] === null) {\n      // Hit empty cell - if we have a word, save it\n      if (currentWord.length >= 3) {\n        words.push([...currentWord]);\n      }\n      currentWord = [];\n    } else {\n      currentWord.push({\n        x,\n        y\n      });\n    }\n    x += dx;\n    y += dy;\n  }\n\n  // Don't forget the word at the end if we hit the board edge\n  if (currentWord.length >= 3) {\n    words.push([...currentWord]);\n  }\n  return words;\n}\n\n/**\n * Find all words on the board (horizontal, vertical, diagonal)\n * Returns array of word positions\n */\nexport function findAllWords(board) {\n  var _board$2;\n  const words = [];\n  const rows = board.length;\n  const cols = ((_board$2 = board[0]) === null || _board$2 === void 0 ? void 0 : _board$2.length) || 0;\n  const seen = new Set();\n\n  // Check each cell as a potential starting point\n  for (let y = 0; y < rows; y++) {\n    for (let x = 0; x < cols; x++) {\n      if (board[y][x] === null) continue;\n\n      // Check each direction\n      for (const {\n        dx,\n        dy\n      } of DIRECTIONS) {\n        const foundWords = findWordsInDirection(board, x, y, dx, dy);\n        for (const wordPositions of foundWords) {\n          // Create a unique key for this word (normalize by sorting positions)\n          const sorted = [...wordPositions].sort((a, b) => {\n            if (a.y !== b.y) return a.y - b.y;\n            return a.x - b.x;\n          });\n          const key = sorted.map(p => `${p.x},${p.y}`).join('|');\n          if (!seen.has(key)) {\n            seen.add(key);\n            words.push(wordPositions);\n          }\n        }\n      }\n    }\n  }\n  return words;\n}\n\n/**\n * Extract word string from board positions\n */\nexport function extractWordFromPositions(board, positions) {\n  // Sort positions to get correct order\n  const sorted = [...positions].sort((a, b) => {\n    if (a.y !== b.y) return a.y - b.y;\n    return a.x - b.x;\n  });\n  const letters = [];\n  for (const pos of sorted) {\n    var _board$pos$y;\n    const tile = (_board$pos$y = board[pos.y]) === null || _board$pos$y === void 0 ? void 0 : _board$pos$y[pos.x];\n    if (tile) {\n      letters.push(tile.letter);\n    }\n  }\n  return letters.join('').trim();\n}\n\n/**\n * Check if positions form a valid straight line (horizontal, vertical, or diagonal)\n */\nexport function isValidWordLine(positions) {\n  if (positions.length < 3) {\n    return false;\n  }\n\n  // Sort positions\n  const sorted = [...positions].sort((a, b) => {\n    if (a.y !== b.y) return a.y - b.y;\n    return a.x - b.x;\n  });\n\n  // Determine direction from first two positions\n  const dx = sorted[1].x - sorted[0].x;\n  const dy = sorted[1].y - sorted[0].y;\n\n  // Check if direction is valid (must be horizontal, vertical, or diagonal)\n  if (dx !== 0 && dy !== 0 && Math.abs(dx) !== Math.abs(dy)) {\n    return false;\n  }\n\n  // Normalize direction\n  const dirX = dx === 0 ? 0 : dx > 0 ? 1 : -1;\n  const dirY = dy === 0 ? 0 : dy > 0 ? 1 : -1;\n\n  // Verify all positions follow the same direction\n  for (let i = 1; i < sorted.length; i++) {\n    const expectedX = sorted[i - 1].x + dirX;\n    const expectedY = sorted[i - 1].y + dirY;\n    if (sorted[i].x !== expectedX || sorted[i].y !== expectedY) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Check if word can be read in reverse direction (for palindrome/emordnilap detection)\n * Returns the reverse word if valid, null otherwise\n */\nexport function getReverseWord(board, positions) {\n  if (!isValidWordLine(positions)) {\n    return null;\n  }\n\n  // Sort positions to get forward word\n  const sorted = [...positions].sort((a, b) => {\n    if (a.y !== b.y) return a.y - b.y;\n    return a.x - b.x;\n  });\n\n  // Extract reverse word (read positions backwards)\n  const letters = [];\n  for (let i = sorted.length - 1; i >= 0; i--) {\n    var _board$pos$y2;\n    const pos = sorted[i];\n    const tile = (_board$pos$y2 = board[pos.y]) === null || _board$pos$y2 === void 0 ? void 0 : _board$pos$y2[pos.x];\n    if (tile) {\n      letters.push(tile.letter);\n    }\n  }\n  return letters.join('').trim();\n}\n\n/**\n * Check if positions contain at least one of the newly placed tiles\n */\nexport function containsNewTile(positions, newlyPlacedTiles) {\n  return positions.some(pos => newlyPlacedTiles.some(newPos => newPos.x === pos.x && newPos.y === pos.y));\n}","map":{"version":3,"names":["DIRECTIONS","dx","dy","findWordsInDirection","board","startX","startY","_board$","words","rows","length","cols","currentWord","x","y","push","findAllWords","_board$2","seen","Set","foundWords","wordPositions","sorted","sort","a","b","key","map","p","join","has","add","extractWordFromPositions","positions","letters","pos","_board$pos$y","tile","letter","trim","isValidWordLine","Math","abs","dirX","dirY","i","expectedX","expectedY","getReverseWord","_board$pos$y2","containsNewTile","newlyPlacedTiles","some","newPos"],"sources":["/Users/sanyasharma/Documents/grabble/react-ui/src/game-engine/word-detection.ts"],"sourcesContent":["/**\n * Copyright (c) 2024 Amuse Labs Pvt Ltd\n * Grabble - Scrabble with Gravity\n * Word detection utilities for finding words on the board\n */\n\nimport type { Position, Tile } from './types';\n\n/**\n * Direction vectors for word detection\n */\nconst DIRECTIONS = [\n    { dx: 1, dy: 0 },   // Horizontal right\n    { dx: 0, dy: 1 },   // Vertical down\n    { dx: 1, dy: 1 },   // Diagonal down-right\n    { dx: 1, dy: -1 }   // Diagonal up-right\n];\n\n/**\n * Find all possible words starting from a position in a given direction\n * Returns array of word positions (each word is an array of positions)\n */\nexport function findWordsInDirection(\n    board: (Tile | null)[][],\n    startX: number,\n    startY: number,\n    dx: number,\n    dy: number\n): Position[][] {\n    const words: Position[][] = [];\n    const rows = board.length;\n    const cols = board[0]?.length || 0;\n\n    // Start from the given position and extend in the direction\n    let currentWord: Position[] = [];\n    \n    // Move backwards first to find the start of any word containing this position\n    let x = startX;\n    let y = startY;\n    \n    // Go backwards until we hit an empty cell or board edge\n    while (x >= 0 && x < cols && y >= 0 && y < rows && board[y][x] !== null) {\n        x -= dx;\n        y -= dy;\n    }\n    \n    // Move forward one step (we went one too far back)\n    x += dx;\n    y += dy;\n    \n    // Now collect positions going forward\n    while (x >= 0 && x < cols && y >= 0 && y < rows) {\n        if (board[y][x] === null) {\n            // Hit empty cell - if we have a word, save it\n            if (currentWord.length >= 3) {\n                words.push([...currentWord]);\n            }\n            currentWord = [];\n        } else {\n            currentWord.push({ x, y });\n        }\n        x += dx;\n        y += dy;\n    }\n    \n    // Don't forget the word at the end if we hit the board edge\n    if (currentWord.length >= 3) {\n        words.push([...currentWord]);\n    }\n    \n    return words;\n}\n\n/**\n * Find all words on the board (horizontal, vertical, diagonal)\n * Returns array of word positions\n */\nexport function findAllWords(board: (Tile | null)[][]): Position[][] {\n    const words: Position[][] = [];\n    const rows = board.length;\n    const cols = board[0]?.length || 0;\n    const seen = new Set<string>();\n\n    // Check each cell as a potential starting point\n    for (let y = 0; y < rows; y++) {\n        for (let x = 0; x < cols; x++) {\n            if (board[y][x] === null) continue;\n\n            // Check each direction\n            for (const { dx, dy } of DIRECTIONS) {\n                const foundWords = findWordsInDirection(board, x, y, dx, dy);\n                \n                for (const wordPositions of foundWords) {\n                    // Create a unique key for this word (normalize by sorting positions)\n                    const sorted = [...wordPositions].sort((a, b) => {\n                        if (a.y !== b.y) return a.y - b.y;\n                        return a.x - b.x;\n                    });\n                    const key = sorted.map(p => `${p.x},${p.y}`).join('|');\n                    \n                    if (!seen.has(key)) {\n                        seen.add(key);\n                        words.push(wordPositions);\n                    }\n                }\n            }\n        }\n    }\n\n    return words;\n}\n\n/**\n * Extract word string from board positions\n */\nexport function extractWordFromPositions(\n    board: (Tile | null)[][],\n    positions: Position[]\n): string {\n    // Sort positions to get correct order\n    const sorted = [...positions].sort((a, b) => {\n        if (a.y !== b.y) return a.y - b.y;\n        return a.x - b.x;\n    });\n\n    const letters: string[] = [];\n    for (const pos of sorted) {\n        const tile = board[pos.y]?.[pos.x];\n        if (tile) {\n            letters.push(tile.letter);\n        }\n    }\n\n    return letters.join('').trim();\n}\n\n/**\n * Check if positions form a valid straight line (horizontal, vertical, or diagonal)\n */\nexport function isValidWordLine(positions: Position[]): boolean {\n    if (positions.length < 3) {\n        return false;\n    }\n\n    // Sort positions\n    const sorted = [...positions].sort((a, b) => {\n        if (a.y !== b.y) return a.y - b.y;\n        return a.x - b.x;\n    });\n\n    // Determine direction from first two positions\n    const dx = sorted[1].x - sorted[0].x;\n    const dy = sorted[1].y - sorted[0].y;\n\n    // Check if direction is valid (must be horizontal, vertical, or diagonal)\n    if (dx !== 0 && dy !== 0 && Math.abs(dx) !== Math.abs(dy)) {\n        return false;\n    }\n\n    // Normalize direction\n    const dirX = dx === 0 ? 0 : (dx > 0 ? 1 : -1);\n    const dirY = dy === 0 ? 0 : (dy > 0 ? 1 : -1);\n\n    // Verify all positions follow the same direction\n    for (let i = 1; i < sorted.length; i++) {\n        const expectedX = sorted[i - 1].x + dirX;\n        const expectedY = sorted[i - 1].y + dirY;\n        if (sorted[i].x !== expectedX || sorted[i].y !== expectedY) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n/**\n * Check if word can be read in reverse direction (for palindrome/emordnilap detection)\n * Returns the reverse word if valid, null otherwise\n */\nexport function getReverseWord(\n    board: (Tile | null)[][],\n    positions: Position[]\n): string | null {\n    if (!isValidWordLine(positions)) {\n        return null;\n    }\n\n    // Sort positions to get forward word\n    const sorted = [...positions].sort((a, b) => {\n        if (a.y !== b.y) return a.y - b.y;\n        return a.x - b.x;\n    });\n\n    // Extract reverse word (read positions backwards)\n    const letters: string[] = [];\n    for (let i = sorted.length - 1; i >= 0; i--) {\n        const pos = sorted[i];\n        const tile = board[pos.y]?.[pos.x];\n        if (tile) {\n            letters.push(tile.letter);\n        }\n    }\n\n    return letters.join('').trim();\n}\n\n/**\n * Check if positions contain at least one of the newly placed tiles\n */\nexport function containsNewTile(\n    positions: Position[],\n    newlyPlacedTiles: Position[]\n): boolean {\n    return positions.some(pos =>\n        newlyPlacedTiles.some(newPos => newPos.x === pos.x && newPos.y === pos.y)\n    );\n}\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}