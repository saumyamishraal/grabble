{"ast":null,"code":"/**\n * Copyright (c) 2024 Amuse Labs Pvt Ltd\n * Grabble - Scrabble with Gravity\n * Word detection utilities for finding words on the board\n *//**\n * Direction vectors for word detection\n */const DIRECTIONS=[{dx:1,dy:0},// Horizontal right\n{dx:0,dy:1},// Vertical down\n{dx:1,dy:1},// Diagonal down-right\n{dx:1,dy:-1}// Diagonal up-right\n];/**\n * Find all possible words starting from a position in a given direction\n * Returns array of word positions (each word is an array of positions)\n */export function findWordsInDirection(board,startX,startY,dx,dy){var _board$;const words=[];const rows=board.length;const cols=((_board$=board[0])===null||_board$===void 0?void 0:_board$.length)||0;// Start from the given position and extend in the direction\nlet currentWord=[];// Move backwards first to find the start of any word containing this position\nlet x=startX;let y=startY;// Go backwards until we hit an empty cell or board edge\nwhile(x>=0&&x<cols&&y>=0&&y<rows&&board[y][x]!==null){x-=dx;y-=dy;}// Move forward one step (we went one too far back)\nx+=dx;y+=dy;// Now collect positions going forward\nwhile(x>=0&&x<cols&&y>=0&&y<rows){if(board[y][x]===null){// Hit empty cell - if we have a word, save it\nif(currentWord.length>=3){words.push([...currentWord]);}currentWord=[];}else{currentWord.push({x,y});}x+=dx;y+=dy;}// Don't forget the word at the end if we hit the board edge\nif(currentWord.length>=3){words.push([...currentWord]);}return words;}/**\n * Find all words on the board (horizontal, vertical, diagonal)\n * Returns array of word positions\n */export function findAllWords(board){var _board$2;const words=[];const rows=board.length;const cols=((_board$2=board[0])===null||_board$2===void 0?void 0:_board$2.length)||0;const seen=new Set();// Check each cell as a potential starting point\nfor(let y=0;y<rows;y++){for(let x=0;x<cols;x++){if(board[y][x]===null)continue;// Check each direction\nfor(const{dx,dy}of DIRECTIONS){const foundWords=findWordsInDirection(board,x,y,dx,dy);for(const wordPositions of foundWords){// Create a unique key for this word (normalize by sorting positions)\nconst sorted=[...wordPositions].sort((a,b)=>{if(a.y!==b.y)return a.y-b.y;return a.x-b.x;});const key=sorted.map(p=>\"\".concat(p.x,\",\").concat(p.y)).join('|');if(!seen.has(key)){seen.add(key);words.push(wordPositions);}}}}}return words;}/**\n * Extract word string from board positions\n */export function extractWordFromPositions(board,positions){// Sort positions to get correct order\nconst sorted=[...positions].sort((a,b)=>{if(a.y!==b.y)return a.y-b.y;return a.x-b.x;});const letters=[];for(const pos of sorted){var _board$pos$y;const tile=(_board$pos$y=board[pos.y])===null||_board$pos$y===void 0?void 0:_board$pos$y[pos.x];if(tile){letters.push(tile.letter);}}return letters.join('').trim();}/**\n * Check if positions form a valid straight line (horizontal, vertical, or diagonal)\n */export function isValidWordLine(positions){if(positions.length<3){return false;}// Sort positions\nconst sorted=[...positions].sort((a,b)=>{if(a.y!==b.y)return a.y-b.y;return a.x-b.x;});// Determine direction from first two positions\nconst dx=sorted[1].x-sorted[0].x;const dy=sorted[1].y-sorted[0].y;// Check if direction is valid (must be horizontal, vertical, or diagonal)\nif(dx!==0&&dy!==0&&Math.abs(dx)!==Math.abs(dy)){return false;}// Normalize direction\nconst dirX=dx===0?0:dx>0?1:-1;const dirY=dy===0?0:dy>0?1:-1;// Verify all positions follow the same direction\nfor(let i=1;i<sorted.length;i++){const expectedX=sorted[i-1].x+dirX;const expectedY=sorted[i-1].y+dirY;if(sorted[i].x!==expectedX||sorted[i].y!==expectedY){return false;}}return true;}/**\n * Check if word can be read in reverse direction (for palindrome/emordnilap detection)\n * Returns the reverse word if valid, null otherwise\n */export function getReverseWord(board,positions){if(!isValidWordLine(positions)){return null;}// Sort positions to get forward word\nconst sorted=[...positions].sort((a,b)=>{if(a.y!==b.y)return a.y-b.y;return a.x-b.x;});// Extract reverse word (read positions backwards)\nconst letters=[];for(let i=sorted.length-1;i>=0;i--){var _board$pos$y2;const pos=sorted[i];const tile=(_board$pos$y2=board[pos.y])===null||_board$pos$y2===void 0?void 0:_board$pos$y2[pos.x];if(tile){letters.push(tile.letter);}}return letters.join('').trim();}/**\n * Check if positions contain at least one of the newly placed tiles\n */export function containsNewTile(positions,newlyPlacedTiles){return positions.some(pos=>newlyPlacedTiles.some(newPos=>newPos.x===pos.x&&newPos.y===pos.y));}","map":{"version":3,"names":["DIRECTIONS","dx","dy","findWordsInDirection","board","startX","startY","_board$","words","rows","length","cols","currentWord","x","y","push","findAllWords","_board$2","seen","Set","foundWords","wordPositions","sorted","sort","a","b","key","map","p","concat","join","has","add","extractWordFromPositions","positions","letters","pos","_board$pos$y","tile","letter","trim","isValidWordLine","Math","abs","dirX","dirY","i","expectedX","expectedY","getReverseWord","_board$pos$y2","containsNewTile","newlyPlacedTiles","some","newPos"],"sources":["/Users/sanyasharma/Documents/grabble/react-ui/src/game-engine/word-detection.ts"],"sourcesContent":["/**\n * Copyright (c) 2024 Amuse Labs Pvt Ltd\n * Grabble - Scrabble with Gravity\n * Word detection utilities for finding words on the board\n */\n\nimport type { Position, Tile } from './types';\n\n/**\n * Direction vectors for word detection\n */\nconst DIRECTIONS = [\n    { dx: 1, dy: 0 },   // Horizontal right\n    { dx: 0, dy: 1 },   // Vertical down\n    { dx: 1, dy: 1 },   // Diagonal down-right\n    { dx: 1, dy: -1 }   // Diagonal up-right\n];\n\n/**\n * Find all possible words starting from a position in a given direction\n * Returns array of word positions (each word is an array of positions)\n */\nexport function findWordsInDirection(\n    board: (Tile | null)[][],\n    startX: number,\n    startY: number,\n    dx: number,\n    dy: number\n): Position[][] {\n    const words: Position[][] = [];\n    const rows = board.length;\n    const cols = board[0]?.length || 0;\n\n    // Start from the given position and extend in the direction\n    let currentWord: Position[] = [];\n    \n    // Move backwards first to find the start of any word containing this position\n    let x = startX;\n    let y = startY;\n    \n    // Go backwards until we hit an empty cell or board edge\n    while (x >= 0 && x < cols && y >= 0 && y < rows && board[y][x] !== null) {\n        x -= dx;\n        y -= dy;\n    }\n    \n    // Move forward one step (we went one too far back)\n    x += dx;\n    y += dy;\n    \n    // Now collect positions going forward\n    while (x >= 0 && x < cols && y >= 0 && y < rows) {\n        if (board[y][x] === null) {\n            // Hit empty cell - if we have a word, save it\n            if (currentWord.length >= 3) {\n                words.push([...currentWord]);\n            }\n            currentWord = [];\n        } else {\n            currentWord.push({ x, y });\n        }\n        x += dx;\n        y += dy;\n    }\n    \n    // Don't forget the word at the end if we hit the board edge\n    if (currentWord.length >= 3) {\n        words.push([...currentWord]);\n    }\n    \n    return words;\n}\n\n/**\n * Find all words on the board (horizontal, vertical, diagonal)\n * Returns array of word positions\n */\nexport function findAllWords(board: (Tile | null)[][]): Position[][] {\n    const words: Position[][] = [];\n    const rows = board.length;\n    const cols = board[0]?.length || 0;\n    const seen = new Set<string>();\n\n    // Check each cell as a potential starting point\n    for (let y = 0; y < rows; y++) {\n        for (let x = 0; x < cols; x++) {\n            if (board[y][x] === null) continue;\n\n            // Check each direction\n            for (const { dx, dy } of DIRECTIONS) {\n                const foundWords = findWordsInDirection(board, x, y, dx, dy);\n                \n                for (const wordPositions of foundWords) {\n                    // Create a unique key for this word (normalize by sorting positions)\n                    const sorted = [...wordPositions].sort((a, b) => {\n                        if (a.y !== b.y) return a.y - b.y;\n                        return a.x - b.x;\n                    });\n                    const key = sorted.map(p => `${p.x},${p.y}`).join('|');\n                    \n                    if (!seen.has(key)) {\n                        seen.add(key);\n                        words.push(wordPositions);\n                    }\n                }\n            }\n        }\n    }\n\n    return words;\n}\n\n/**\n * Extract word string from board positions\n */\nexport function extractWordFromPositions(\n    board: (Tile | null)[][],\n    positions: Position[]\n): string {\n    // Sort positions to get correct order\n    const sorted = [...positions].sort((a, b) => {\n        if (a.y !== b.y) return a.y - b.y;\n        return a.x - b.x;\n    });\n\n    const letters: string[] = [];\n    for (const pos of sorted) {\n        const tile = board[pos.y]?.[pos.x];\n        if (tile) {\n            letters.push(tile.letter);\n        }\n    }\n\n    return letters.join('').trim();\n}\n\n/**\n * Check if positions form a valid straight line (horizontal, vertical, or diagonal)\n */\nexport function isValidWordLine(positions: Position[]): boolean {\n    if (positions.length < 3) {\n        return false;\n    }\n\n    // Sort positions\n    const sorted = [...positions].sort((a, b) => {\n        if (a.y !== b.y) return a.y - b.y;\n        return a.x - b.x;\n    });\n\n    // Determine direction from first two positions\n    const dx = sorted[1].x - sorted[0].x;\n    const dy = sorted[1].y - sorted[0].y;\n\n    // Check if direction is valid (must be horizontal, vertical, or diagonal)\n    if (dx !== 0 && dy !== 0 && Math.abs(dx) !== Math.abs(dy)) {\n        return false;\n    }\n\n    // Normalize direction\n    const dirX = dx === 0 ? 0 : (dx > 0 ? 1 : -1);\n    const dirY = dy === 0 ? 0 : (dy > 0 ? 1 : -1);\n\n    // Verify all positions follow the same direction\n    for (let i = 1; i < sorted.length; i++) {\n        const expectedX = sorted[i - 1].x + dirX;\n        const expectedY = sorted[i - 1].y + dirY;\n        if (sorted[i].x !== expectedX || sorted[i].y !== expectedY) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n/**\n * Check if word can be read in reverse direction (for palindrome/emordnilap detection)\n * Returns the reverse word if valid, null otherwise\n */\nexport function getReverseWord(\n    board: (Tile | null)[][],\n    positions: Position[]\n): string | null {\n    if (!isValidWordLine(positions)) {\n        return null;\n    }\n\n    // Sort positions to get forward word\n    const sorted = [...positions].sort((a, b) => {\n        if (a.y !== b.y) return a.y - b.y;\n        return a.x - b.x;\n    });\n\n    // Extract reverse word (read positions backwards)\n    const letters: string[] = [];\n    for (let i = sorted.length - 1; i >= 0; i--) {\n        const pos = sorted[i];\n        const tile = board[pos.y]?.[pos.x];\n        if (tile) {\n            letters.push(tile.letter);\n        }\n    }\n\n    return letters.join('').trim();\n}\n\n/**\n * Check if positions contain at least one of the newly placed tiles\n */\nexport function containsNewTile(\n    positions: Position[],\n    newlyPlacedTiles: Position[]\n): boolean {\n    return positions.some(pos =>\n        newlyPlacedTiles.some(newPos => newPos.x === pos.x && newPos.y === pos.y)\n    );\n}\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}