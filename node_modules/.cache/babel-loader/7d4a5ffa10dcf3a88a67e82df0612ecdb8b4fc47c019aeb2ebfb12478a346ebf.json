{"ast":null,"code":"import _objectSpread from\"/Users/sanyasharma/Documents/grabble/react-ui/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";/**\n * Copyright (c) 2024 Amuse Labs Pvt Ltd\n * Grabble - Scrabble with Gravity\n * Core game engine with game logic\n */import{STANDARD_SCRABBLE_DISTRIBUTION}from'./types';import{isValidWordLine,extractWordFromPositions,getReverseWord,containsNewTile}from'./word-detection';/**\n * Core game engine for Grabble\n */export class GrabbleEngine{constructor(state){this.state=void 0;this.state=state;}/**\n     * Get current game state\n     */getState(){return JSON.parse(JSON.stringify(this.state));// Deep copy\n}/**\n     * Initialize a new tile bag from standard Scrabble distribution\n     */static createTileBag(){const bag=[];for(const[letter,{count,points}]of Object.entries(STANDARD_SCRABBLE_DISTRIBUTION)){for(let i=0;i<count;i++){bag.push({letter,points});}}return this.shuffle(bag);}/**\n     * Shuffle array using Fisher-Yates algorithm\n     */static shuffle(array){const shuffled=[...array];for(let i=shuffled.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[shuffled[i],shuffled[j]]=[shuffled[j],shuffled[i]];}return shuffled;}/**\n     * Initialize empty 7x7 board\n     */static createEmptyBoard(){const board=[];for(let y=0;y<7;y++){board[y]=[];for(let x=0;x<7;x++){board[y][x]=null;}}return board;}/**\n     * Place tiles from column tops (row 0)\n     * Tiles are placed first, then gravity resolves\n     */placeTiles(placements,playerId){// Place tiles at top of columns\nfor(const placement of placements){const{column,tile}=placement;if(column<0||column>=7){throw new Error(\"Invalid column: \".concat(column));}// Find first empty cell in column (starting from top)\nlet placed=false;for(let row=0;row<7;row++){if(this.state.board[row][column]===null){this.state.board[row][column]=_objectSpread(_objectSpread({},tile),{},{playerId});placed=true;break;}}if(!placed){throw new Error(\"Column \".concat(column,\" is full\"));}}// Resolve gravity after all placements\nthis.resolveGravity();}/**\n     * Resolve gravity - tiles fall straight down until they hit bottom or another tile\n     */resolveGravity(){// Process each column independently\nfor(let col=0;col<7;col++){// Collect all tiles in this column (top to bottom)\nconst tiles=[];for(let row=0;row<7;row++){const tile=this.state.board[row][col];if(tile!==null){tiles.push(tile);this.state.board[row][col]=null;}}// Place tiles back from bottom up\nlet rowIndex=6;// Start from bottom row\nfor(let i=tiles.length-1;i>=0;i--){this.state.board[rowIndex][col]=tiles[i];rowIndex--;}}}/**\n     * Extract word from board given positions\n     * Returns the word string and validates it's a straight line\n     */extractWord(positions){if(!isValidWordLine(positions)){return{word:'',isValid:false};}// Verify all positions have tiles\nfor(const pos of positions){var _this$state$board$pos;if(((_this$state$board$pos=this.state.board[pos.y])===null||_this$state$board$pos===void 0?void 0:_this$state$board$pos[pos.x])===null){return{word:'',isValid:false};}}const word=extractWordFromPositions(this.state.board,positions);return{word,isValid:word.length>=3};}/**\n     * Check if word is a palindrome (same forward and backward)\n     */isPalindrome(word){const cleaned=word.replace(/\\s+/g,'').toUpperCase();return cleaned===cleaned.split('').reverse().join('');}/**\n     * Check if word is an emordnilap (reverses to a different valid word)\n     * Uses the reverse word from board positions to handle multi-character tiles correctly\n     */async isEmordnilap(word,positions,dictionary){const reverseWord=getReverseWord(this.state.board,positions);if(!reverseWord){return false;}const reverseUpper=reverseWord.toUpperCase();const wordUpper=word.toUpperCase();return reverseUpper!==wordUpper&&dictionary.has(reverseUpper);}/**\n     * Calculate word score with bonuses\n     */async calculateWordScore(word,positions,dictionary){// Base score: sum of letter values\nlet baseScore=0;for(const pos of positions){const tile=this.state.board[pos.y][pos.x];if(tile){baseScore+=tile.points;}}const bonuses=[];let multiplier=1;// Check if diagonal word\nif(positions.length>0){const dx=positions[positions.length-1].x-positions[0].x;const dy=positions[positions.length-1].y-positions[0].y;if(dx!==0&&dy!==0){bonuses.push('diagonal');multiplier*=2;}}// Check if palindrome\nif(this.isPalindrome(word)){bonuses.push('palindrome');multiplier*=2;}// Check if emordnilap\nif(await this.isEmordnilap(word,positions,dictionary)){bonuses.push('emordnilap');multiplier*=2;}return{score:baseScore*multiplier,bonuses};}/**\n     * Validate word claim\n     * Returns validation result with error message if invalid\n     */async validateWordClaim(claim,newlyPlacedTiles,dictionary){// Extract word\nconst{word,isValid}=this.extractWord(claim.positions);if(!isValid){return{valid:false,error:'Word must be a straight line of 3+ letters'};}// Check dictionary\nif(!dictionary.has(word.toUpperCase())){return{valid:false,error:'Word not in dictionary'};}// Check if word contains at least one newly placed tile\nif(!containsNewTile(claim.positions,newlyPlacedTiles)){return{valid:false,error:'Word must contain at least one newly placed tile'};}// Check if word already claimed\nconst wordAlreadyClaimed=this.state.claimedWords.some(cw=>{if(cw.word.toUpperCase()!==word.toUpperCase())return false;// Check if positions overlap (same word in same location)\nreturn cw.positions.some(cwPos=>claim.positions.some(claimPos=>cwPos.x===claimPos.x&&cwPos.y===claimPos.y));});if(wordAlreadyClaimed){return{valid:false,error:'Word already claimed'};}// Calculate score\nconst{score,bonuses}=await this.calculateWordScore(word,claim.positions,dictionary);return{valid:true,word,score,bonuses};}/**\n     * Process word claims for a turn\n     * Returns validation results for each claim\n     */async processWordClaims(claims,newlyPlacedTiles,dictionary){const results=[];let totalScore=0;for(const claim of claims){const result=await this.validateWordClaim(claim,newlyPlacedTiles,dictionary);results.push(result);if(result.valid&&result.score!==undefined){totalScore+=result.score;}}// If any claim is invalid, entire move is rejected\nconst allValid=results.every(r=>r.valid);if(!allValid){return{valid:false,results,totalScore:0};}// All valid - record claimed words and update scores\nfor(let i=0;i<claims.length;i++){const claim=claims[i];const result=results[i];if(result.valid&&result.word&&result.score!==undefined){this.state.claimedWords.push({word:result.word,positions:claim.positions,playerId:claim.playerId,score:result.score,bonuses:result.bonuses||[]});// Update player score\nconst player=this.state.players.find(p=>p.id===claim.playerId);if(player){player.score+=result.score;}}}return{valid:true,results,totalScore};}/**\n     * Draw tiles from bag to fill player rack (up to 7 tiles)\n     */refillPlayerRack(playerId){const player=this.state.players.find(p=>p.id===playerId);if(!player){throw new Error(\"Player \".concat(playerId,\" not found\"));}while(player.rack.length<7&&this.state.tileBag.length>0){const tile=this.state.tileBag.pop();player.rack.push(tile);}}/**\n     * Swap tiles (player discards selected tiles, draws new ones)\n     */swapTiles(playerId,tileIndices){const player=this.state.players.find(p=>p.id===playerId);if(!player){throw new Error(\"Player \".concat(playerId,\" not found\"));}// Remove selected tiles from rack\nconst removedTiles=[];for(const index of tileIndices.sort((a,b)=>b-a)){// Sort descending to remove from end\nif(index>=0&&index<player.rack.length){removedTiles.push(player.rack.splice(index,1)[0]);}}// Return tiles to bag and shuffle\nthis.state.tileBag.push(...removedTiles);this.state.tileBag=GrabbleEngine.shuffle(this.state.tileBag);// Draw new tiles\nwhile(player.rack.length<7&&this.state.tileBag.length>0){const tile=this.state.tileBag.pop();player.rack.push(tile);}}/**\n     * Advance to next player's turn\n     */advanceTurn(){const currentPlayer=this.state.players.find(p=>p.id===this.state.currentPlayerId);if(!currentPlayer){throw new Error(\"Current player \".concat(this.state.currentPlayerId,\" not found\"));}const currentTurnOrder=currentPlayer.turnOrder;const nextTurnOrder=(currentTurnOrder+1)%this.state.players.length;const nextPlayer=this.state.players.find(p=>p.turnOrder===nextTurnOrder);if(nextPlayer){this.state.currentPlayerId=nextPlayer.id;}}/**\n     * Check win condition\n     * Returns winner ID if game is won, null otherwise\n     */checkWinCondition(){for(const player of this.state.players){if(player.score>=this.state.targetScore){this.state.gameStatus='finished';this.state.winnerId=player.id;return player.id;}}return null;}/**\n     * Check if game can continue (tiles available and legal moves possible)\n     */canContinueGame(){// If tile bag is empty and all players have empty racks, game ends\nif(this.state.tileBag.length===0){const allRacksEmpty=this.state.players.every(p=>p.rack.length===0);if(allRacksEmpty){return false;}}return true;}}","map":{"version":3,"names":["STANDARD_SCRABBLE_DISTRIBUTION","isValidWordLine","extractWordFromPositions","getReverseWord","containsNewTile","GrabbleEngine","constructor","state","getState","JSON","parse","stringify","createTileBag","bag","letter","count","points","Object","entries","i","push","shuffle","array","shuffled","length","j","Math","floor","random","createEmptyBoard","board","y","x","placeTiles","placements","playerId","placement","column","tile","Error","concat","placed","row","_objectSpread","resolveGravity","col","tiles","rowIndex","extractWord","positions","word","isValid","pos","_this$state$board$pos","isPalindrome","cleaned","replace","toUpperCase","split","reverse","join","isEmordnilap","dictionary","reverseWord","reverseUpper","wordUpper","has","calculateWordScore","baseScore","bonuses","multiplier","dx","dy","score","validateWordClaim","claim","newlyPlacedTiles","valid","error","wordAlreadyClaimed","claimedWords","some","cw","cwPos","claimPos","processWordClaims","claims","results","totalScore","result","undefined","allValid","every","r","player","players","find","p","id","refillPlayerRack","rack","tileBag","pop","swapTiles","tileIndices","removedTiles","index","sort","a","b","splice","advanceTurn","currentPlayer","currentPlayerId","currentTurnOrder","turnOrder","nextTurnOrder","nextPlayer","checkWinCondition","targetScore","gameStatus","winnerId","canContinueGame","allRacksEmpty"],"sources":["/Users/sanyasharma/Documents/grabble/react-ui/src/game-engine/game-engine.ts"],"sourcesContent":["/**\n * Copyright (c) 2024 Amuse Labs Pvt Ltd\n * Grabble - Scrabble with Gravity\n * Core game engine with game logic\n */\n\nimport type { Tile, Position, TilePlacement, WordClaim, ClaimedWord, GameState, Player } from './types';\nimport { STANDARD_SCRABBLE_DISTRIBUTION } from './types';\nimport { isValidWordLine, extractWordFromPositions, getReverseWord, containsNewTile } from './word-detection';\n\n/**\n * Core game engine for Grabble\n */\nexport class GrabbleEngine {\n    private state: GameState;\n\n    constructor(state: GameState) {\n        this.state = state;\n    }\n\n    /**\n     * Get current game state\n     */\n    getState(): GameState {\n        return JSON.parse(JSON.stringify(this.state)); // Deep copy\n    }\n\n    /**\n     * Initialize a new tile bag from standard Scrabble distribution\n     */\n    static createTileBag(): Tile[] {\n        const bag: Tile[] = [];\n        for (const [letter, { count, points }] of Object.entries(STANDARD_SCRABBLE_DISTRIBUTION)) {\n            for (let i = 0; i < count; i++) {\n                bag.push({ letter, points });\n            }\n        }\n        return this.shuffle(bag);\n    }\n\n    /**\n     * Shuffle array using Fisher-Yates algorithm\n     */\n    static shuffle<T>(array: T[]): T[] {\n        const shuffled = [...array];\n        for (let i = shuffled.length - 1; i > 0; i--) {\n            const j = Math.floor(Math.random() * (i + 1));\n            [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\n        }\n        return shuffled;\n    }\n\n    /**\n     * Initialize empty 7x7 board\n     */\n    static createEmptyBoard(): (Tile | null)[][] {\n        const board: (Tile | null)[][] = [];\n        for (let y = 0; y < 7; y++) {\n            board[y] = [];\n            for (let x = 0; x < 7; x++) {\n                board[y][x] = null;\n            }\n        }\n        return board;\n    }\n\n    /**\n     * Place tiles from column tops (row 0)\n     * Tiles are placed first, then gravity resolves\n     */\n    placeTiles(placements: TilePlacement[], playerId: number): void {\n        // Place tiles at top of columns\n        for (const placement of placements) {\n            const { column, tile } = placement;\n            if (column < 0 || column >= 7) {\n                throw new Error(`Invalid column: ${column}`);\n            }\n            \n            // Find first empty cell in column (starting from top)\n            let placed = false;\n            for (let row = 0; row < 7; row++) {\n                if (this.state.board[row][column] === null) {\n                    this.state.board[row][column] = {\n                        ...tile,\n                        playerId\n                    };\n                    placed = true;\n                    break;\n                }\n            }\n            \n            if (!placed) {\n                throw new Error(`Column ${column} is full`);\n            }\n        }\n\n        // Resolve gravity after all placements\n        this.resolveGravity();\n    }\n\n    /**\n     * Resolve gravity - tiles fall straight down until they hit bottom or another tile\n     */\n    private resolveGravity(): void {\n        // Process each column independently\n        for (let col = 0; col < 7; col++) {\n            // Collect all tiles in this column (top to bottom)\n            const tiles: Tile[] = [];\n            for (let row = 0; row < 7; row++) {\n                const tile = this.state.board[row][col];\n                if (tile !== null) {\n                    tiles.push(tile);\n                    this.state.board[row][col] = null;\n                }\n            }\n\n            // Place tiles back from bottom up\n            let rowIndex = 6; // Start from bottom row\n            for (let i = tiles.length - 1; i >= 0; i--) {\n                this.state.board[rowIndex][col] = tiles[i];\n                rowIndex--;\n            }\n        }\n    }\n\n    /**\n     * Extract word from board given positions\n     * Returns the word string and validates it's a straight line\n     */\n    extractWord(positions: Position[]): { word: string; isValid: boolean } {\n        if (!isValidWordLine(positions)) {\n            return { word: '', isValid: false };\n        }\n\n        // Verify all positions have tiles\n        for (const pos of positions) {\n            if (this.state.board[pos.y]?.[pos.x] === null) {\n                return { word: '', isValid: false };\n            }\n        }\n\n        const word = extractWordFromPositions(this.state.board, positions);\n        return { word, isValid: word.length >= 3 };\n    }\n\n    /**\n     * Check if word is a palindrome (same forward and backward)\n     */\n    isPalindrome(word: string): boolean {\n        const cleaned = word.replace(/\\s+/g, '').toUpperCase();\n        return cleaned === cleaned.split('').reverse().join('');\n    }\n\n    /**\n     * Check if word is an emordnilap (reverses to a different valid word)\n     * Uses the reverse word from board positions to handle multi-character tiles correctly\n     */\n    async isEmordnilap(word: string, positions: Position[], dictionary: Set<string>): Promise<boolean> {\n        const reverseWord = getReverseWord(this.state.board, positions);\n        if (!reverseWord) {\n            return false;\n        }\n        const reverseUpper = reverseWord.toUpperCase();\n        const wordUpper = word.toUpperCase();\n        return reverseUpper !== wordUpper && dictionary.has(reverseUpper);\n    }\n\n    /**\n     * Calculate word score with bonuses\n     */\n    async calculateWordScore(\n        word: string,\n        positions: Position[],\n        dictionary: Set<string>\n    ): Promise<{ score: number; bonuses: string[] }> {\n        // Base score: sum of letter values\n        let baseScore = 0;\n        for (const pos of positions) {\n            const tile = this.state.board[pos.y][pos.x];\n            if (tile) {\n                baseScore += tile.points;\n            }\n        }\n\n        const bonuses: string[] = [];\n        let multiplier = 1;\n\n        // Check if diagonal word\n        if (positions.length > 0) {\n            const dx = positions[positions.length - 1].x - positions[0].x;\n            const dy = positions[positions.length - 1].y - positions[0].y;\n            if (dx !== 0 && dy !== 0) {\n                bonuses.push('diagonal');\n                multiplier *= 2;\n            }\n        }\n\n        // Check if palindrome\n        if (this.isPalindrome(word)) {\n            bonuses.push('palindrome');\n            multiplier *= 2;\n        }\n\n        // Check if emordnilap\n        if (await this.isEmordnilap(word, positions, dictionary)) {\n            bonuses.push('emordnilap');\n            multiplier *= 2;\n        }\n\n        return {\n            score: baseScore * multiplier,\n            bonuses\n        };\n    }\n\n    /**\n     * Validate word claim\n     * Returns validation result with error message if invalid\n     */\n    async validateWordClaim(\n        claim: WordClaim,\n        newlyPlacedTiles: Position[],\n        dictionary: Set<string>\n    ): Promise<{ valid: boolean; error?: string; word?: string; score?: number; bonuses?: string[] }> {\n        // Extract word\n        const { word, isValid } = this.extractWord(claim.positions);\n        if (!isValid) {\n            return { valid: false, error: 'Word must be a straight line of 3+ letters' };\n        }\n\n        // Check dictionary\n        if (!dictionary.has(word.toUpperCase())) {\n            return { valid: false, error: 'Word not in dictionary' };\n        }\n\n        // Check if word contains at least one newly placed tile\n        if (!containsNewTile(claim.positions, newlyPlacedTiles)) {\n            return { valid: false, error: 'Word must contain at least one newly placed tile' };\n        }\n\n        // Check if word already claimed\n        const wordAlreadyClaimed = this.state.claimedWords.some(cw => {\n            if (cw.word.toUpperCase() !== word.toUpperCase()) return false;\n            // Check if positions overlap (same word in same location)\n            return cw.positions.some(cwPos =>\n                claim.positions.some(claimPos => cwPos.x === claimPos.x && cwPos.y === claimPos.y)\n            );\n        });\n        if (wordAlreadyClaimed) {\n            return { valid: false, error: 'Word already claimed' };\n        }\n\n        // Calculate score\n        const { score, bonuses } = await this.calculateWordScore(word, claim.positions, dictionary);\n\n        return {\n            valid: true,\n            word,\n            score,\n            bonuses\n        };\n    }\n\n    /**\n     * Process word claims for a turn\n     * Returns validation results for each claim\n     */\n    async processWordClaims(\n        claims: WordClaim[],\n        newlyPlacedTiles: Position[],\n        dictionary: Set<string>\n    ): Promise<{\n        valid: boolean;\n        results: Array<{ valid: boolean; error?: string; word?: string; score?: number; bonuses?: string[] }>;\n        totalScore: number;\n    }> {\n        const results = [];\n        let totalScore = 0;\n\n        for (const claim of claims) {\n            const result = await this.validateWordClaim(claim, newlyPlacedTiles, dictionary);\n            results.push(result);\n            if (result.valid && result.score !== undefined) {\n                totalScore += result.score;\n            }\n        }\n\n        // If any claim is invalid, entire move is rejected\n        const allValid = results.every(r => r.valid);\n        if (!allValid) {\n            return { valid: false, results, totalScore: 0 };\n        }\n\n        // All valid - record claimed words and update scores\n        for (let i = 0; i < claims.length; i++) {\n            const claim = claims[i];\n            const result = results[i];\n            if (result.valid && result.word && result.score !== undefined) {\n                this.state.claimedWords.push({\n                    word: result.word,\n                    positions: claim.positions,\n                    playerId: claim.playerId,\n                    score: result.score,\n                    bonuses: result.bonuses || []\n                });\n\n                // Update player score\n                const player = this.state.players.find(p => p.id === claim.playerId);\n                if (player) {\n                    player.score += result.score;\n                }\n            }\n        }\n\n        return { valid: true, results, totalScore };\n    }\n\n    /**\n     * Draw tiles from bag to fill player rack (up to 7 tiles)\n     */\n    refillPlayerRack(playerId: number): void {\n        const player = this.state.players.find(p => p.id === playerId);\n        if (!player) {\n            throw new Error(`Player ${playerId} not found`);\n        }\n\n        while (player.rack.length < 7 && this.state.tileBag.length > 0) {\n            const tile = this.state.tileBag.pop()!;\n            player.rack.push(tile);\n        }\n    }\n\n    /**\n     * Swap tiles (player discards selected tiles, draws new ones)\n     */\n    swapTiles(playerId: number, tileIndices: number[]): void {\n        const player = this.state.players.find(p => p.id === playerId);\n        if (!player) {\n            throw new Error(`Player ${playerId} not found`);\n        }\n\n        // Remove selected tiles from rack\n        const removedTiles: Tile[] = [];\n        for (const index of tileIndices.sort((a, b) => b - a)) { // Sort descending to remove from end\n            if (index >= 0 && index < player.rack.length) {\n                removedTiles.push(player.rack.splice(index, 1)[0]);\n            }\n        }\n\n        // Return tiles to bag and shuffle\n        this.state.tileBag.push(...removedTiles);\n        this.state.tileBag = GrabbleEngine.shuffle(this.state.tileBag);\n\n        // Draw new tiles\n        while (player.rack.length < 7 && this.state.tileBag.length > 0) {\n            const tile = this.state.tileBag.pop()!;\n            player.rack.push(tile);\n        }\n    }\n\n    /**\n     * Advance to next player's turn\n     */\n    advanceTurn(): void {\n        const currentPlayer = this.state.players.find(p => p.id === this.state.currentPlayerId);\n        if (!currentPlayer) {\n            throw new Error(`Current player ${this.state.currentPlayerId} not found`);\n        }\n\n        const currentTurnOrder = currentPlayer.turnOrder;\n        const nextTurnOrder = (currentTurnOrder + 1) % this.state.players.length;\n        const nextPlayer = this.state.players.find(p => p.turnOrder === nextTurnOrder);\n        \n        if (nextPlayer) {\n            this.state.currentPlayerId = nextPlayer.id;\n        }\n    }\n\n    /**\n     * Check win condition\n     * Returns winner ID if game is won, null otherwise\n     */\n    checkWinCondition(): number | null {\n        for (const player of this.state.players) {\n            if (player.score >= this.state.targetScore) {\n                this.state.gameStatus = 'finished';\n                this.state.winnerId = player.id;\n                return player.id;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Check if game can continue (tiles available and legal moves possible)\n     */\n    canContinueGame(): boolean {\n        // If tile bag is empty and all players have empty racks, game ends\n        if (this.state.tileBag.length === 0) {\n            const allRacksEmpty = this.state.players.every(p => p.rack.length === 0);\n            if (allRacksEmpty) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}